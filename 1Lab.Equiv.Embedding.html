<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="keywords" content="Agda,categories,topos" />

  <title>1Lab.Equiv.Embedding - 1Lab</title>

  <link rel="stylesheet" href="/css/default.css" />
  <link rel="stylesheet" href="/css/katex.min.css" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="1Lab.Equiv.Embedding - 1Lab" />
  <meta name="twitter:image" content="https://1lab.dev/static/cube-128x.png" />

  <meta name="og:title" content="1Lab.Equiv.Embedding - 1Lab" />
  <meta name="og:image" content="https://1lab.dev/static/cube-128x.png" />
  <meta name="og:site-name" content="1Lab" />
  <meta name="og:type" content="website" />

    <meta name="og:description" content="&lt;p&gt;We formalise
&lt;em&gt;embeddings&lt;/em&gt;, a homotopically well-behaved generalisation of
injective functions. Itâ€™s immediate from our definition that every
injective function between sets is an embedding, and that every
equivalence is an embedding.&lt;/p&gt;" />
  <meta name="twitter:description" content="&lt;p&gt;We formalise
&lt;em&gt;embeddings&lt;/em&gt;, a homotopically well-behaved generalisation of
injective functions. Itâ€™s immediate from our definition that every
injective function between sets is an embedding, and that every
equivalence is an embedding.&lt;/p&gt;" />
  <meta name="description" content="&lt;p&gt;We formalise &lt;em&gt;embeddings&lt;/em&gt;,
a homotopically well-behaved generalisation of injective functions. Itâ€™s
immediate from our definition that every injective function between sets
is an embedding, and that every equivalence is an embedding.&lt;/p&gt;" />
  
  <script defer src="/main.js"></script>

  <noscript>
    <style>
      body span.reasoning-step .as-written {
        display: inline;
      }

      body span.reasoning-step .alternate {
        display: none;
      }
    </style>
  </noscript>

  <!-- Google font embeds -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400;0,500;0,600;0,700;0,800;1,400;1,500;1,600;1,700;1,800&amp;family=Inria+Sans:ital,wght@0,300;0,400;0,700;1,300;1,400;1,700&amp;display=swap" rel="stylesheet">
</head>

<body class="text-page">
<main>
<div id="post-toc-container" style="padding-left: 1em; padding-right: 1em;">

  <!-- Table of contents (only if the page has a table of contents) -->
    <aside id="toc">
    <div id="toc-container" style="min-width: 10em; font-size: 15pt;">
      <!-- Title for the page -->
      <h3 class="Agda" style="margin-top: 0; margin-bottom: 0; white-space: pre;">
                <a class="Module">1Lab.Equiv.Embedding</a>
              </h3>

      <!-- Cube logo -->
      <a id="logo" href="/">
        <img alt="1Lab" src="/static/cube-72x.png" style="display: block; margin-bottom: 1em; margin: auto;" width="32px" height="32px" />
      </a>

      <!-- Actual table of contents (separated from the rest by
      horizontal rules) -->
      <hr />
      <ul>
      <li><a href="#embeddings"><a href="#embeddings" class="header-link">Embeddings<span class="header-link-emoji">ğŸ”—</span></a></a></li>
      </ul>
      <hr />

      <!-- Sidebar controls -->
      <div style="display: flex; gap: 0.25em; flex-flow: row wrap;">
        <!-- Sidebar equations control -->
        <span class="equations" style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-eqns" type="checkbox" class="equations" id="sidebar-eqns">
          <label for="sidebar-eqns">Equations</label>
        </span>

        <!-- Sidebar fonts control -->
        <span style="display: flex; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-font" type="checkbox" id="toggle-fonts">
          <label for="toggle-fonts">Serif Font</label>
        </span>

        <!-- Sidebar footnotes control -->
        <span class="inline-footnotes" style="display: none; align-items: center; gap: 0.25em; flex-wrap: nowrap;">
          <input name="sidebar-fns" type="checkbox" class="inline-footnotes" id="sidebar-fns">
          <label for="sidebar-fns">Inline Footnotes</label>
        </span>
      </div>

      <hr />

      <!-- Navbar navigation (lol) -->
      <div id="return" style="white-space: nowrap;">
        <div class="search-form search-form-proxy" role="form">
          <input id="search-box-proxy" type_="text" placeholder="Search..." autocomplete="off" tabindex="0"></input>
        </div>

              <a href="/">back to index</a> <br />
              <a href="all-pages.html">view all pages</a> <br />
        <a href="https://github.com/plt-amy/cubical-1lab/blob/c4a8622243c83c929bba8590e960752ac2ff2a88/src/1Lab/Equiv/Embedding.lagda.md">link to source</a> <br />
                <hr /> <div class="author-list">Written by AmÃ©lia Liao and uni</div> <br />
              </div>
    </div>
  </aside>
  
  <article>
    <!-- Article navigation (narrow screens only) -->
    <div class="narrow-only" id="article-nav">
      <!-- Index return anchor (only if the page is not the index) -->
            <div id="return">
        <a href="/">back to index</a>
      </div>
      
      <!-- Navbar equations control -->
      <span class="equations" style="display: flex; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-eqns" type="checkbox" class="equations" id="navbar-eqns">
        <label for="navbar-eqns">Equations</label>
      </span>

      <!-- Navbar footnotes control -->
      <span class="inline-footnotes" style="display: none; gap: 0.25em; flex-wrap: nowrap;">
        <input name="navbar-fns" type="checkbox" class="inline-footnotes" id="navbar-fns">
        <label for="navbar-fns">Inline Footnotes</label>
      </span>
    </div>

<pre class="Agda"><a id="274" class="Keyword">open</a> <a id="279" class="Keyword">import</a> <a id="286" href="1Lab.HLevel.Retracts.html" class="Module">1Lab.HLevel.Retracts</a>
<a id="307" class="Keyword">open</a> <a id="312" class="Keyword">import</a> <a id="319" href="1Lab.HLevel.Universe.html" class="Module">1Lab.HLevel.Universe</a>
<a id="340" class="Keyword">open</a> <a id="345" class="Keyword">import</a> <a id="352" href="1Lab.Path.Groupoid.html" class="Module">1Lab.Path.Groupoid</a>
<a id="371" class="Keyword">open</a> <a id="376" class="Keyword">import</a> <a id="383" href="1Lab.Type.Sigma.html" class="Module">1Lab.Type.Sigma</a>
<a id="399" class="Keyword">open</a> <a id="404" class="Keyword">import</a> <a id="411" href="1Lab.Univalence.html" class="Module">1Lab.Univalence</a>
<a id="427" class="Keyword">open</a> <a id="432" class="Keyword">import</a> <a id="439" href="1Lab.Type.Pi.html" class="Module">1Lab.Type.Pi</a>
<a id="452" class="Keyword">open</a> <a id="457" class="Keyword">import</a> <a id="464" href="1Lab.HLevel.html" class="Module">1Lab.HLevel</a>
<a id="476" class="Keyword">open</a> <a id="481" class="Keyword">import</a> <a id="488" href="1Lab.Equiv.html" class="Module">1Lab.Equiv</a>
<a id="499" class="Keyword">open</a> <a id="504" class="Keyword">import</a> <a id="511" href="1Lab.Path.html" class="Module">1Lab.Path</a>
<a id="521" class="Keyword">open</a> <a id="526" class="Keyword">import</a> <a id="533" href="1Lab.Type.html" class="Module">1Lab.Type</a>

<a id="544" class="Keyword">module</a> <a id="551" href="1Lab.Equiv.Embedding.html" class="Module">1Lab.Equiv.Embedding</a> <a id="572" class="Keyword">where</a>
</pre>
<!--
<pre class="Agda"><a id="592" class="Keyword">private</a> <a id="600" class="Keyword">variable</a>
  <a id="611" href="1Lab.Equiv.Embedding.html#611" class="Generalizable">â„“</a> <a id="613" href="1Lab.Equiv.Embedding.html#613" class="Generalizable">â„“â‚</a> <a id="616" class="Symbol">:</a> <a id="618" href="Agda.Primitive.html#597" data-type="Type" class="Postulate">Level</a>
  <a id="626" href="1Lab.Equiv.Embedding.html#626" class="Generalizable">A</a> <a id="628" href="1Lab.Equiv.Embedding.html#628" class="Generalizable">B</a> <a id="630" class="Symbol">:</a> <a id="632" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="637" href="1Lab.Equiv.Embedding.html#611" class="Generalizable">â„“</a>
  <a id="641" href="1Lab.Equiv.Embedding.html#641" class="Generalizable">w</a> <a id="643" href="1Lab.Equiv.Embedding.html#643" class="Generalizable">x</a> <a id="645" class="Symbol">:</a> <a id="647" href="1Lab.Equiv.Embedding.html#626" class="Generalizable">A</a>
</pre>-->
<h1 id="embeddings"><a href="#embeddings" class="header-link">Embeddings<span class="header-link-emoji">ğŸ”—</span></a></h1>
<p>One of the most important observations leading to the development of
categorical set theory is that injective maps <em>into</em> a set
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>
correspond to maps <em>from</em>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span></span></span></span>
<em>into</em> a universe of propositions, normally denoted
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Î©</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Î©</span></span></span></span>.</span>
Classically, this object is
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">Î©</mi><mo>=</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\Omega = \{ 0 , 1 \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">Î©</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose">}</span></span></span></span>,</span>
but there are other settings in which this idea makes sense (<a href="https://ncatlab.org/nlab/show/elementary+topos">elementary
topoi</a>) where the <em>subobject classifier</em> is not a coproduct
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>âˆ</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">1 \coprod 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-symbol small-op" style="position:relative;top:0em;">âˆ</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span></span></span></span>.</span></p>
<p>To develop this correspondence, we note that, if a map is
<span class="Agda"><a href="1Lab.Equiv.Embedding.html#1419" class="Function">injective</a></span>
and its codomain is a [set], then all the <code class="sourceCode agda">fibres</code>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>f</mi><mo>âˆ—</mo></msup><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f^*(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6887em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">âˆ—</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>
are <a href="1Lab.HLevel.html#is-prop">propositions</a>.</p>
<pre class="Agda"><a id="injective"></a><a id="1419" href="1Lab.Equiv.Embedding.html#1419" data-type="(A â†’ Bâ‚) â†’ Type (A.â„“ âŠ” B.â„“)" class="Function">injective</a> <a id="1429" class="Symbol">:</a> <a id="1431" class="Symbol">(</a><a id="1432" href="1Lab.Equiv.Embedding.html#626" class="Generalizable">A</a> <a id="1434" class="Symbol">â†’</a> <a id="1436" href="1Lab.Equiv.Embedding.html#628" class="Generalizable">B</a><a id="1437" class="Symbol">)</a> <a id="1439" class="Symbol">â†’</a> <a id="1441" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="1446" class="Symbol">_</a>
<a id="1448" href="1Lab.Equiv.Embedding.html#1419" data-type="(A â†’ Bâ‚) â†’ Type (A.â„“ âŠ” B.â„“)" class="Function">injective</a> <a id="1458" href="1Lab.Equiv.Embedding.html#1458" class="Bound">f</a> <a id="1460" class="Symbol">=</a> <a id="1462" class="Symbol">âˆ€</a> <a id="1464" class="Symbol">{</a><a id="1465" href="1Lab.Equiv.Embedding.html#1465" class="Bound">x</a> <a id="1467" href="1Lab.Equiv.Embedding.html#1467" class="Bound">y</a><a id="1468" class="Symbol">}</a> <a id="1470" class="Symbol">â†’</a> <a id="1472" href="1Lab.Equiv.Embedding.html#1458" class="Bound">f</a> <a id="1474" href="1Lab.Equiv.Embedding.html#1465" class="Bound">x</a> <a id="1476" href="Agda.Builtin.Cubical.Path.html#388" data-type="A â†’ A â†’ Type â„“" class="Function Operator">â‰¡</a> <a id="1478" href="1Lab.Equiv.Embedding.html#1458" class="Bound">f</a> <a id="1480" href="1Lab.Equiv.Embedding.html#1467" class="Bound">y</a> <a id="1482" class="Symbol">â†’</a> <a id="1484" href="1Lab.Equiv.Embedding.html#1465" class="Bound">x</a> <a id="1486" href="Agda.Builtin.Cubical.Path.html#388" data-type="A â†’ A â†’ Type â„“" class="Function Operator">â‰¡</a> <a id="1488" href="1Lab.Equiv.Embedding.html#1467" class="Bound">y</a>

<a id="injective-between-setsâ†’has-prop-fibres"></a><a id="1491" href="1Lab.Equiv.Embedding.html#1491" data-type="is-set Bâ‚ â†’
(f : A â†’ Bâ‚) â†’ injective f â†’ (x : Bâ‚) â†’ is-prop (fibre f x)" class="Function">injective-between-setsâ†’has-prop-fibres</a>
  <a id="1532" class="Symbol">:</a> <a id="1534" href="1Lab.HLevel.html#3356" data-type="Type â„“ â†’ Type â„“" class="Function">is-set</a> <a id="1541" href="1Lab.Equiv.Embedding.html#628" class="Generalizable">B</a> <a id="1543" class="Symbol">â†’</a> <a id="1545" class="Symbol">(</a><a id="1546" href="1Lab.Equiv.Embedding.html#1546" class="Bound">f</a> <a id="1548" class="Symbol">:</a> <a id="1550" href="1Lab.Equiv.Embedding.html#626" class="Generalizable">A</a> <a id="1552" class="Symbol">â†’</a> <a id="1554" href="1Lab.Equiv.Embedding.html#628" class="Generalizable">B</a><a id="1555" class="Symbol">)</a> <a id="1557" class="Symbol">â†’</a> <a id="1559" href="1Lab.Equiv.Embedding.html#1419" data-type="(A â†’ Bâ‚) â†’ Type (A.â„“ âŠ” B.â„“)" class="Function">injective</a> <a id="1569" href="1Lab.Equiv.Embedding.html#1546" class="Bound">f</a>
  <a id="1573" class="Symbol">â†’</a> <a id="1575" class="Symbol">âˆ€</a> <a id="1577" href="1Lab.Equiv.Embedding.html#1577" class="Bound">x</a> <a id="1579" class="Symbol">â†’</a> <a id="1581" href="1Lab.HLevel.html#2597" data-type="Type â„“ â†’ Type â„“" class="Function">is-prop</a> <a id="1589" class="Symbol">(</a><a id="1590" href="1Lab.Equiv.html#1873" data-type="(A â†’ Bâ‚) â†’ Bâ‚ â†’ Type (A.â„“â‚ âŠ” B.â„“â‚)" class="Function">fibre</a> <a id="1596" href="1Lab.Equiv.Embedding.html#1546" class="Bound">f</a> <a id="1598" href="1Lab.Equiv.Embedding.html#1577" class="Bound">x</a><a id="1599" class="Symbol">)</a>
<a id="1601" href="1Lab.Equiv.Embedding.html#1491" data-type="is-set Bâ‚ â†’
(f : A â†’ Bâ‚) â†’ injective f â†’ (x : Bâ‚) â†’ is-prop (fibre f x)" class="Function">injective-between-setsâ†’has-prop-fibres</a> <a id="1640" href="1Lab.Equiv.Embedding.html#1640" class="Bound">bset</a> <a id="1645" href="1Lab.Equiv.Embedding.html#1645" class="Bound">f</a> <a id="1647" href="1Lab.Equiv.Embedding.html#1647" class="Bound">inj</a> <a id="1651" href="1Lab.Equiv.Embedding.html#1651" class="Bound">x</a> <a id="1653" class="Symbol">(</a><a id="1654" href="1Lab.Equiv.Embedding.html#1654" class="Bound">f*x</a> <a id="1658" href="Agda.Builtin.Sigma.html#236" data-type="(fstâ‚ : A) (sndâ‚ : Bâ‚ fstâ‚) â†’ âˆ‘ A Bâ‚" class="InductiveConstructor Operator">,</a> <a id="1660" href="1Lab.Equiv.Embedding.html#1660" class="Bound">p</a><a id="1661" class="Symbol">)</a> <a id="1663" class="Symbol">(</a><a id="1664" href="1Lab.Equiv.Embedding.html#1664" class="Bound">f*xâ€²</a> <a id="1669" href="Agda.Builtin.Sigma.html#236" data-type="(fstâ‚ : A) (sndâ‚ : Bâ‚ fstâ‚) â†’ âˆ‘ A Bâ‚" class="InductiveConstructor Operator">,</a> <a id="1671" href="1Lab.Equiv.Embedding.html#1671" class="Bound">q</a><a id="1672" class="Symbol">)</a> <a id="1674" class="Symbol">=</a>
  <a id="1678" href="1Lab.Type.Sigma.html#5139" data-type="((x : A) â†’ is-prop (Bâ‚ x)) â†’ x .fst â‰¡ y .fst â†’ x â‰¡ y" class="Function">Î£-prop-path</a> <a id="1690" class="Symbol">(Î»</a> <a id="1693" href="1Lab.Equiv.Embedding.html#1693" class="Bound">x</a> <a id="1695" class="Symbol">â†’</a> <a id="1697" href="1Lab.Equiv.Embedding.html#1640" class="Bound">bset</a> <a id="1702" class="Symbol">_</a> <a id="1704" class="Symbol">_)</a> <a id="1707" class="Symbol">(</a><a id="1708" href="1Lab.Equiv.Embedding.html#1647" class="Bound">inj</a> <a id="1712" class="Symbol">(</a><a id="1713" href="1Lab.Equiv.Embedding.html#1660" class="Bound">p</a> <a id="1715" href="1Lab.Path.html#39472" data-type="x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z" class="Function Operator">âˆ™</a> <a id="1717" href="1Lab.Path.html#10558" data-type="x â‰¡ y â†’ y â‰¡ x" class="Function">sym</a> <a id="1721" href="1Lab.Equiv.Embedding.html#1671" class="Bound">q</a><a id="1722" class="Symbol">))</a>
</pre>
<p>In fact, this condition is not only necessary, it is also sufficient.
Thus, we conclude that, <strong>for maps between sets</strong>, these
notions are equivalent, and we could take either as the definition of
â€œsubset inclusionâ€.</p>
<pre class="Agda"><a id="has-prop-fibresâ†’injective"></a><a id="1956" href="1Lab.Equiv.Embedding.html#1956" data-type="(f : A â†’ Bâ‚) â†’ ((x : Bâ‚) â†’ is-prop (fibre f x)) â†’ injective f" class="Function">has-prop-fibresâ†’injective</a>
  <a id="1984" class="Symbol">:</a> <a id="1986" class="Symbol">(</a><a id="1987" href="1Lab.Equiv.Embedding.html#1987" class="Bound">f</a> <a id="1989" class="Symbol">:</a> <a id="1991" href="1Lab.Equiv.Embedding.html#626" class="Generalizable">A</a> <a id="1993" class="Symbol">â†’</a> <a id="1995" href="1Lab.Equiv.Embedding.html#628" class="Generalizable">B</a><a id="1996" class="Symbol">)</a> <a id="1998" class="Symbol">â†’</a> <a id="2000" class="Symbol">(âˆ€</a> <a id="2003" href="1Lab.Equiv.Embedding.html#2003" class="Bound">x</a> <a id="2005" class="Symbol">â†’</a> <a id="2007" href="1Lab.HLevel.html#2597" data-type="Type â„“ â†’ Type â„“" class="Function">is-prop</a> <a id="2015" class="Symbol">(</a><a id="2016" href="1Lab.Equiv.html#1873" data-type="(A â†’ Bâ‚) â†’ Bâ‚ â†’ Type (A.â„“â‚ âŠ” B.â„“â‚)" class="Function">fibre</a> <a id="2022" href="1Lab.Equiv.Embedding.html#1987" class="Bound">f</a> <a id="2024" href="1Lab.Equiv.Embedding.html#2003" class="Bound">x</a><a id="2025" class="Symbol">))</a>
  <a id="2030" class="Symbol">â†’</a> <a id="2032" href="1Lab.Equiv.Embedding.html#1419" data-type="(A â†’ Bâ‚) â†’ Type (A.â„“ âŠ” B.â„“)" class="Function">injective</a> <a id="2042" href="1Lab.Equiv.Embedding.html#1987" class="Bound">f</a>
<a id="2044" href="1Lab.Equiv.Embedding.html#1956" data-type="(f : A â†’ Bâ‚) â†’ ((x : Bâ‚) â†’ is-prop (fibre f x)) â†’ injective f" class="Function">has-prop-fibresâ†’injective</a> <a id="2070" class="Symbol">_</a> <a id="2072" href="1Lab.Equiv.Embedding.html#2072" class="Bound">prop</a> <a id="2077" href="1Lab.Equiv.Embedding.html#2077" class="Bound">p</a> <a id="2079" class="Symbol">=</a> <a id="2081" href="1Lab.Path.html#20756" data-type="(f : (x : A) â†’ Bâ‚ x) (p : x â‰¡ y) â†’
PathP (Î» i â†’ Bâ‚ (p i)) (f x) (f y)" class="Function">ap</a> <a id="2084" href="Agda.Builtin.Sigma.html#252" data-type="âˆ‘ A Bâ‚ â†’ A" class="Field">fst</a> <a id="2088" class="Symbol">(</a><a id="2089" href="1Lab.Equiv.Embedding.html#2072" class="Bound">prop</a> <a id="2094" class="Symbol">_</a> <a id="2096" class="Symbol">(_</a> <a id="2099" href="Agda.Builtin.Sigma.html#236" data-type="(fstâ‚ : A) (sndâ‚ : Bâ‚ fstâ‚) â†’ âˆ‘ A Bâ‚" class="InductiveConstructor Operator">,</a> <a id="2101" href="1Lab.Equiv.Embedding.html#2077" class="Bound">p</a><a id="2102" class="Symbol">)</a> <a id="2104" class="Symbol">(_</a> <a id="2107" href="Agda.Builtin.Sigma.html#236" data-type="(fstâ‚ : A) (sndâ‚ : Bâ‚ fstâ‚) â†’ âˆ‘ A Bâ‚" class="InductiveConstructor Operator">,</a> <a id="2109" href="1Lab.Path.html#3593" data-type="x â‰¡ x" class="Function">refl</a><a id="2113" class="Symbol">))</a>

<a id="between-sets-injectiveâ‰ƒhas-prop-fibres"></a><a id="2117" href="1Lab.Equiv.Embedding.html#2117" data-type="is-set A â†’
is-set Bâ‚ â†’
(f : A â†’ Bâ‚) â†’ injective f â‰ƒ ((x : Bâ‚) â†’ is-prop (fibre f x))" class="Function">between-sets-injectiveâ‰ƒhas-prop-fibres</a>
  <a id="2158" class="Symbol">:</a> <a id="2160" href="1Lab.HLevel.html#3356" data-type="Type â„“ â†’ Type â„“" class="Function">is-set</a> <a id="2167" href="1Lab.Equiv.Embedding.html#626" class="Generalizable">A</a> <a id="2169" class="Symbol">â†’</a> <a id="2171" href="1Lab.HLevel.html#3356" data-type="Type â„“ â†’ Type â„“" class="Function">is-set</a> <a id="2178" href="1Lab.Equiv.Embedding.html#628" class="Generalizable">B</a> <a id="2180" class="Symbol">â†’</a> <a id="2182" class="Symbol">(</a><a id="2183" href="1Lab.Equiv.Embedding.html#2183" class="Bound">f</a> <a id="2185" class="Symbol">:</a> <a id="2187" href="1Lab.Equiv.Embedding.html#626" class="Generalizable">A</a> <a id="2189" class="Symbol">â†’</a> <a id="2191" href="1Lab.Equiv.Embedding.html#628" class="Generalizable">B</a><a id="2192" class="Symbol">)</a>
  <a id="2196" class="Symbol">â†’</a> <a id="2198" href="1Lab.Equiv.Embedding.html#1419" data-type="(A â†’ Bâ‚) â†’ Type (A.â„“ âŠ” B.â„“)" class="Function">injective</a> <a id="2208" href="1Lab.Equiv.Embedding.html#2183" class="Bound">f</a> <a id="2210" href="1Lab.Equiv.html#2439" data-type="Type â„“â‚ â†’ Type â„“â‚‚ â†’ Type (â„“â‚ âŠ” â„“â‚‚)" class="Function Operator">â‰ƒ</a> <a id="2212" class="Symbol">(âˆ€</a> <a id="2215" href="1Lab.Equiv.Embedding.html#2215" class="Bound">x</a> <a id="2217" class="Symbol">â†’</a> <a id="2219" href="1Lab.HLevel.html#2597" data-type="Type â„“ â†’ Type â„“" class="Function">is-prop</a> <a id="2227" class="Symbol">(</a><a id="2228" href="1Lab.Equiv.html#1873" data-type="(A â†’ Bâ‚) â†’ Bâ‚ â†’ Type (A.â„“â‚ âŠ” B.â„“â‚)" class="Function">fibre</a> <a id="2234" href="1Lab.Equiv.Embedding.html#2183" class="Bound">f</a> <a id="2236" href="1Lab.Equiv.Embedding.html#2215" class="Bound">x</a><a id="2237" class="Symbol">))</a>
<a id="2240" href="1Lab.Equiv.Embedding.html#2117" data-type="is-set A â†’
is-set Bâ‚ â†’
(f : A â†’ Bâ‚) â†’ injective f â‰ƒ ((x : Bâ‚) â†’ is-prop (fibre f x))" class="Function">between-sets-injectiveâ‰ƒhas-prop-fibres</a> <a id="2279" href="1Lab.Equiv.Embedding.html#2279" class="Bound">aset</a> <a id="2284" href="1Lab.Equiv.Embedding.html#2284" class="Bound">bset</a> <a id="2289" href="1Lab.Equiv.Embedding.html#2289" class="Bound">f</a> <a id="2291" class="Symbol">=</a>
  <a id="2295" href="1Lab.Equiv.html#23456" data-type="is-prop P â†’ is-prop Q â†’ (P â†’ Q) â†’ (Q â†’ P) â†’ P â‰ƒ Q" class="Function">prop-ext</a> <a id="2304" class="Symbol">(Î»</a> <a id="2307" href="1Lab.Equiv.Embedding.html#2307" class="Bound">p</a> <a id="2309" href="1Lab.Equiv.Embedding.html#2309" class="Bound">q</a> <a id="2311" href="1Lab.Equiv.Embedding.html#2311" class="Bound">i</a> <a id="2313" href="1Lab.Equiv.Embedding.html#2313" class="Bound">x</a> <a id="2315" class="Symbol">â†’</a> <a id="2317" href="1Lab.Equiv.Embedding.html#2279" class="Bound">aset</a> <a id="2322" class="Symbol">_</a> <a id="2324" class="Symbol">_</a> <a id="2326" class="Symbol">(</a><a id="2327" href="1Lab.Equiv.Embedding.html#2307" class="Bound">p</a> <a id="2329" href="1Lab.Equiv.Embedding.html#2313" class="Bound">x</a><a id="2330" class="Symbol">)</a> <a id="2332" class="Symbol">(</a><a id="2333" href="1Lab.Equiv.Embedding.html#2309" class="Bound">q</a> <a id="2335" href="1Lab.Equiv.Embedding.html#2313" class="Bound">x</a><a id="2336" class="Symbol">)</a> <a id="2338" href="1Lab.Equiv.Embedding.html#2311" class="Bound">i</a><a id="2339" class="Symbol">)</a>
           <a id="2352" class="Symbol">(</a><a id="2353" href="1Lab.HLevel.Retracts.html#4507" data-type="(n : Nat) â†’
((x : A) â†’ is-hlevel (Bâ‚ x) n) â†’ is-hlevel ((x : A) â†’ Bâ‚ x) n" class="Function">Î -is-hlevel</a> <a id="2365" class="Number">1</a> <a id="2367" class="Symbol">Î»</a> <a id="2369" href="1Lab.Equiv.Embedding.html#2369" class="Bound">_</a> <a id="2371" class="Symbol">â†’</a> <a id="2373" href="1Lab.HLevel.html#12235" data-type="is-prop (is-prop A)" class="Function">is-prop-is-prop</a><a id="2388" class="Symbol">)</a>
           <a id="2401" class="Symbol">(</a><a id="2402" href="1Lab.Equiv.Embedding.html#1491" data-type="is-set Bâ‚ â†’
(f : A â†’ Bâ‚) â†’ injective f â†’ (x : Bâ‚) â†’ is-prop (fibre f x)" class="Function">injective-between-setsâ†’has-prop-fibres</a> <a id="2441" href="1Lab.Equiv.Embedding.html#2284" class="Bound">bset</a> <a id="2446" href="1Lab.Equiv.Embedding.html#2289" class="Bound">f</a><a id="2447" class="Symbol">)</a>
           <a id="2460" class="Symbol">(</a><a id="2461" href="1Lab.Equiv.Embedding.html#1956" data-type="(f : A â†’ Bâ‚) â†’ ((x : Bâ‚) â†’ is-prop (fibre f x)) â†’ injective f" class="Function">has-prop-fibresâ†’injective</a> <a id="2487" href="1Lab.Equiv.Embedding.html#2289" class="Bound">f</a><a id="2488" class="Symbol">)</a>
</pre>
<p>However, for more general types, like the circle, this fails: A
function can have propositional fibres in at most one way, but a
function can be injective in more than one. Consider the following two
witnesses of injectivity for the identity map of the circle, i.e., two
functions
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mi>y</mi><mo>â†’</mo><mi>x</mi><mo>=</mo><mi>y</mi></mrow><annotation encoding="application/x-tex">x = y â†’ x = y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â†’</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>.</span></p>
<pre class="Agda"><a id="2802" class="Keyword">module</a> <a id="2809" href="1Lab.Equiv.Embedding.html#2809" class="Module">_</a> <a id="2811" class="Keyword">where</a> <a id="2817" class="Keyword">private</a>
  <a id="2827" class="Keyword">open</a> <a id="2832" class="Keyword">import</a> <a id="2839" href="1Lab.HIT.S1.html" class="Module">1Lab.HIT.S1</a>

  <a id="2854" href="1Lab.Equiv.Embedding.html#2854" class="Function">circle-id</a> <a id="2864" class="Symbol">:</a> <a id="2866" href="1Lab.HIT.S1.html#622" data-type="Type" class="Datatype">SÂ¹</a> <a id="2869" class="Symbol">â†’</a> <a id="2871" href="1Lab.HIT.S1.html#622" data-type="Type" class="Datatype">SÂ¹</a>
  <a id="2876" href="1Lab.Equiv.Embedding.html#2854" class="Function">circle-id</a> <a id="2886" href="1Lab.Equiv.Embedding.html#2886" class="Bound">p</a> <a id="2888" class="Symbol">=</a> <a id="2890" href="1Lab.Equiv.Embedding.html#2886" class="Bound">p</a>
</pre>
<p>The first is the boring option: it just gives back the same path,
unchanged. The second is more interesting: By doing circle induction, we
can consider the cases separately, and in the case where
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mrow><mi mathvariant="normal">b</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">s</mi><mi mathvariant="normal">e</mi></mrow></mrow><annotation encoding="application/x-tex">y = \id{base}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord"><span class="mord mathrm">base</span></span></span></span></span>,</span>
we add an extra twist onto the path:</p>
<pre class="Agda">  <a id="3158" href="1Lab.Equiv.Embedding.html#3158" class="Function">circle-id-injâ‚</a> <a id="3173" href="1Lab.Equiv.Embedding.html#3173" class="Function">circle-id-injâ‚‚</a> <a id="3188" class="Symbol">:</a> <a id="3190" href="1Lab.Equiv.Embedding.html#1419" data-type="(A â†’ Bâ‚) â†’ Type (A.â„“ âŠ” B.â„“)" class="Function">injective</a> <a id="3200" href="1Lab.Equiv.Embedding.html#2854" class="Function">circle-id</a>
  <a id="3212" href="1Lab.Equiv.Embedding.html#3158" class="Function">circle-id-injâ‚</a> <a id="3227" href="1Lab.Equiv.Embedding.html#3227" class="Bound">p</a> <a id="3229" class="Symbol">=</a> <a id="3231" href="1Lab.Equiv.Embedding.html#3227" class="Bound">p</a>
  <a id="3235" href="1Lab.Equiv.Embedding.html#3173" class="Function">circle-id-injâ‚‚</a> <a id="3250" class="Symbol">{</a><a id="3251" href="1Lab.Equiv.Embedding.html#3251" class="Bound">x</a><a id="3252" class="Symbol">}</a> <a id="3254" class="Symbol">=</a>
    <a id="3260" href="1Lab.HIT.S1.html#2141" data-type="(pb : P base) â†’ PathP (Î» i â†’ P (loop i)) pb pb â†’ (x : SÂ¹) â†’ P x" class="Function">SÂ¹-elim</a> <a id="3268" class="Symbol">{</a><a id="3269" class="Argument">P</a> <a id="3271" class="Symbol">=</a> <a id="3273" class="Symbol">Î»</a> <a id="3275" href="1Lab.Equiv.Embedding.html#3275" class="Bound">y</a> <a id="3277" class="Symbol">â†’</a> <a id="3279" href="1Lab.Equiv.Embedding.html#3251" class="Bound">x</a> <a id="3281" href="Agda.Builtin.Cubical.Path.html#388" data-type="A â†’ A â†’ Type â„“" class="Function Operator">â‰¡</a> <a id="3283" href="1Lab.Equiv.Embedding.html#3275" class="Bound">y</a> <a id="3285" class="Symbol">â†’</a> <a id="3287" href="1Lab.Equiv.Embedding.html#3251" class="Bound">x</a> <a id="3289" href="Agda.Builtin.Cubical.Path.html#388" data-type="A â†’ A â†’ Type â„“" class="Function Operator">â‰¡</a> <a id="3291" href="1Lab.Equiv.Embedding.html#3275" class="Bound">y</a><a id="3292" class="Symbol">}</a> <a id="3294" class="Symbol">(</a><a id="3295" href="1Lab.Path.html#39472" data-type="x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z" class="Function Operator">_âˆ™</a> <a id="3298" href="1Lab.HIT.S1.html#652" data-type="base â‰¡ base" class="InductiveConstructor">loop</a><a id="3302" class="Symbol">)</a>
      <a id="3310" class="Symbol">(</a><a id="3311" href="1Lab.Type.Pi.html#2570" data-type="((p : PathP A xâ‚€ xâ‚) â†’ PathP (Î» i â†’ Bâ‚ i (p i)) (f xâ‚€) (g xâ‚)) â†’
PathP (Î» i â†’ (x : A i) â†’ Bâ‚ i x) f g" class="Function">funext-dep</a> <a id="3322" class="Symbol">Î»</a> <a id="3324" href="1Lab.Equiv.Embedding.html#3324" class="Bound">p</a> <a id="3326" class="Symbol">â†’</a> <a id="3328" href="1Lab.Path.html#55988" data-type="coe0â†’1 A x â‰¡ y â†’ PathP A x y" class="Function">to-pathp</a> <a id="3337" class="Symbol">(</a><a id="3338" href="1Lab.Path.html#61413" data-type="(loopâ‚ : x â‰¡ z) (adj : z â‰¡ y) â†’
subst (_â‰¡_ x) adj loopâ‚ â‰¡ loopâ‚ âˆ™ adj" class="Function">subst-path-right</a> <a id="3355" class="Symbol">_</a> <a id="3357" class="Symbol">_</a> <a id="3359" href="1Lab.Path.html#39472" data-type="x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z" class="Function Operator">âˆ™</a> <a id="3361" href="1Lab.Equiv.Embedding.html#3395" class="Function">lemma</a> <a id="3367" href="1Lab.Equiv.Embedding.html#3324" class="Bound">p</a><a id="3368" class="Symbol">))</a>
      <a id="3377" class="Symbol">_</a>
    <a id="3383" class="Keyword">where</a>
      <a id="3395" href="1Lab.Equiv.Embedding.html#3395" class="Function">lemma</a> <a id="3401" class="Symbol">:</a> <a id="3403" class="Symbol">âˆ€</a> <a id="3405" class="Symbol">{</a><a id="3406" href="1Lab.Equiv.Embedding.html#3406" class="Bound">x</a><a id="3407" class="Symbol">}</a> <a id="3409" class="Symbol">{</a><a id="3410" href="1Lab.Equiv.Embedding.html#3410" class="Bound">p1</a> <a id="3413" href="1Lab.Equiv.Embedding.html#3413" class="Bound">p2</a> <a id="3416" class="Symbol">:</a> <a id="3418" href="1Lab.Equiv.Embedding.html#3406" class="Bound">x</a> <a id="3420" href="Agda.Builtin.Cubical.Path.html#388" data-type="A â†’ A â†’ Type â„“" class="Function Operator">â‰¡</a> <a id="3422" href="1Lab.HIT.S1.html#640" data-type="SÂ¹" class="InductiveConstructor">base</a><a id="3426" class="Symbol">}</a>
            <a id="3440" class="Symbol">â†’</a> <a id="3442" href="Agda.Builtin.Cubical.Path.html#197" data-type="(A : I â†’ Type â„“) â†’ A i0 â†’ A i1 â†’ Type â„“" class="Postulate">PathP</a> <a id="3448" class="Symbol">(Î»</a> <a id="3451" href="1Lab.Equiv.Embedding.html#3451" class="Bound">i</a> <a id="3453" class="Symbol">â†’</a> <a id="3455" href="1Lab.Equiv.Embedding.html#3406" class="Bound">x</a> <a id="3457" href="Agda.Builtin.Cubical.Path.html#388" data-type="A â†’ A â†’ Type â„“" class="Function Operator">â‰¡</a> <a id="3459" href="1Lab.HIT.S1.html#652" data-type="base â‰¡ base" class="InductiveConstructor">loop</a> <a id="3464" href="1Lab.Equiv.Embedding.html#3451" class="Bound">i</a><a id="3465" class="Symbol">)</a> <a id="3467" href="1Lab.Equiv.Embedding.html#3410" class="Bound">p1</a> <a id="3470" href="1Lab.Equiv.Embedding.html#3413" class="Bound">p2</a>
            <a id="3485" class="Symbol">â†’</a> <a id="3487" class="Symbol">(</a><a id="3488" href="1Lab.Equiv.Embedding.html#3410" class="Bound">p1</a> <a id="3491" href="1Lab.Path.html#39472" data-type="x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z" class="Function Operator">âˆ™</a> <a id="3493" href="1Lab.HIT.S1.html#652" data-type="base â‰¡ base" class="InductiveConstructor">loop</a><a id="3497" class="Symbol">)</a> <a id="3499" href="1Lab.Path.html#39472" data-type="x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z" class="Function Operator">âˆ™</a> <a id="3501" href="1Lab.HIT.S1.html#652" data-type="base â‰¡ base" class="InductiveConstructor">loop</a> <a id="3506" href="Agda.Builtin.Cubical.Path.html#388" data-type="A â†’ A â†’ Type â„“" class="Function Operator">â‰¡</a> <a id="3508" href="1Lab.Equiv.Embedding.html#3413" class="Bound">p2</a> <a id="3511" href="1Lab.Path.html#39472" data-type="x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z" class="Function Operator">âˆ™</a> <a id="3513" href="1Lab.HIT.S1.html#652" data-type="base â‰¡ base" class="InductiveConstructor">loop</a>
      <a id="3524" href="1Lab.Equiv.Embedding.html#3395" class="Function">lemma</a> <a id="3530" href="1Lab.Equiv.Embedding.html#3530" class="Bound">path</a> <a id="3535" class="Symbol">=</a> <a id="3537" href="1Lab.Path.html#20756" data-type="(f : (x : A) â†’ Bâ‚ x) (p : x â‰¡ y) â†’
PathP (Î» i â†’ Bâ‚ (p i)) (f x) (f y)" class="Function">ap</a> <a id="3540" class="Symbol">(</a><a id="3541" href="1Lab.Path.html#39472" data-type="x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z" class="Function Operator">_âˆ™</a> <a id="3544" href="1Lab.HIT.S1.html#652" data-type="base â‰¡ base" class="InductiveConstructor">loop</a><a id="3548" class="Symbol">)</a> <a id="3550" class="Symbol">(</a><a id="3551" href="1Lab.Path.html#56213" data-type="PathP A x y â†’ coe0â†’1 A x â‰¡ y" class="Function">from-pathp</a> <a id="3562" href="1Lab.Equiv.Embedding.html#3530" class="Bound">path</a><a id="3566" class="Symbol">)</a>
</pre>
<p>These functions are <em>not the same</em>! When given
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>,
<span class="Agda"><a href="1Lab.Equiv.Embedding.html#3158" class="Function">circle-id-injâ‚</a></span>
will give
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>
(because itâ€™s boring), but the exciting function will give
<span class="Agda"><a href="1Lab.HIT.S1.html#652" class="InductiveConstructor">loop</a></span>.
And that ainâ€™t
<span class="Agda"><a href="1Lab.Path.html#3593" class="Function">refl</a></span>.</p>
<pre class="Agda">  <a id="3798" href="1Lab.Equiv.Embedding.html#3798" class="Function">circle-id-injâ‚â‰ injâ‚‚</a> <a id="3818" class="Symbol">:</a> <a id="3820" href="1Lab.Equiv.Embedding.html#3158" class="Function">circle-id-injâ‚</a> <a id="3835" href="Agda.Builtin.Cubical.Path.html#388" data-type="A â†’ A â†’ Type â„“" class="Function Operator">â‰¡</a> <a id="3837" href="1Lab.Equiv.Embedding.html#3173" class="Function">circle-id-injâ‚‚</a> <a id="3852" class="Symbol">â†’</a> <a id="3854" href="1Lab.Type.html#1336" data-type="Type" class="Datatype">âŠ¥</a>
  <a id="3858" href="1Lab.Equiv.Embedding.html#3798" class="Function">circle-id-injâ‚â‰ injâ‚‚</a> <a id="3878" href="1Lab.Equiv.Embedding.html#3878" class="Bound">p</a> <a id="3880" class="Symbol">=</a> <a id="3882" href="1Lab.HIT.S1.html#1873" data-type="refl â‰¡ loop â†’ âŠ¥" class="Function">reflâ‰ loop</a> <a id="3892" class="Symbol">(</a><a id="3893" href="1Lab.Path.html#58127" data-type="f â‰¡ g â†’ (x : A) â†’ f x â‰¡ g x" class="Function">happly</a> <a id="3900" href="1Lab.Equiv.Embedding.html#3878" class="Bound">p</a> <a id="3902" href="1Lab.Path.html#3593" data-type="x â‰¡ x" class="Function">refl</a> <a id="3907" href="1Lab.Path.html#39472" data-type="x â‰¡ y â†’ y â‰¡ z â†’ x â‰¡ z" class="Function Operator">âˆ™</a> <a id="3909" href="1Lab.Path.Groupoid.html#4623" data-type="(p : x â‰¡ y) â†’ refl âˆ™ p â‰¡ p" class="Function">âˆ™-id-l</a> <a id="3916" class="Symbol">_)</a>
</pre>
<p>Since we want â€œis a subtype inclusionâ€ to be a property â€” that is, we
really want to <em>not</em> care about <em>how</em> a function is a
subtype inclusion, only that it is, we define
<strong>embeddings</strong> as those functions which have propositional
fibres:</p>
<pre class="Agda"><a id="is-embedding"></a><a id="4172" href="1Lab.Equiv.Embedding.html#4172" data-type="(A â†’ Bâ‚) â†’ Type (A.â„“ âŠ” B.â„“)" class="Function">is-embedding</a> <a id="4185" class="Symbol">:</a> <a id="4187" class="Symbol">(</a><a id="4188" href="1Lab.Equiv.Embedding.html#626" class="Generalizable">A</a> <a id="4190" class="Symbol">â†’</a> <a id="4192" href="1Lab.Equiv.Embedding.html#628" class="Generalizable">B</a><a id="4193" class="Symbol">)</a> <a id="4195" class="Symbol">â†’</a> <a id="4197" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4202" class="Symbol">_</a>
<a id="4204" href="1Lab.Equiv.Embedding.html#4172" data-type="(A â†’ Bâ‚) â†’ Type (A.â„“ âŠ” B.â„“)" class="Function">is-embedding</a> <a id="4217" href="1Lab.Equiv.Embedding.html#4217" class="Bound">f</a> <a id="4219" class="Symbol">=</a> <a id="4221" class="Symbol">âˆ€</a> <a id="4223" href="1Lab.Equiv.Embedding.html#4223" class="Bound">x</a> <a id="4225" class="Symbol">â†’</a> <a id="4227" href="1Lab.HLevel.html#2597" data-type="Type â„“ â†’ Type â„“" class="Function">is-prop</a> <a id="4235" class="Symbol">(</a><a id="4236" href="1Lab.Equiv.html#1873" data-type="(A â†’ Bâ‚) â†’ Bâ‚ â†’ Type (A.â„“â‚ âŠ” B.â„“â‚)" class="Function">fibre</a> <a id="4242" href="1Lab.Equiv.Embedding.html#4217" class="Bound">f</a> <a id="4244" href="1Lab.Equiv.Embedding.html#4223" class="Bound">x</a><a id="4245" class="Symbol">)</a>

<a id="_â†ª_"></a><a id="4248" href="1Lab.Equiv.Embedding.html#4248" data-type="Type â„“ â†’ Type â„“â‚ â†’ Type (â„“ âŠ” â„“â‚)" class="Function Operator">_â†ª_</a> <a id="4252" class="Symbol">:</a> <a id="4254" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4259" href="1Lab.Equiv.Embedding.html#611" class="Generalizable">â„“</a> <a id="4261" class="Symbol">â†’</a> <a id="4263" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4268" href="1Lab.Equiv.Embedding.html#613" class="Generalizable">â„“â‚</a> <a id="4271" class="Symbol">â†’</a> <a id="4273" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4278" class="Symbol">_</a>
<a id="4280" href="1Lab.Equiv.Embedding.html#4280" class="Bound">A</a> <a id="4282" href="1Lab.Equiv.Embedding.html#4248" data-type="Type â„“ â†’ Type â„“â‚ â†’ Type (â„“ âŠ” â„“â‚)" class="Function Operator">â†ª</a> <a id="4284" href="1Lab.Equiv.Embedding.html#4284" class="Bound">B</a> <a id="4286" class="Symbol">=</a> <a id="4288" href="1Lab.Type.html#1573" data-type="(Bâ‚ : A â†’ Type b) â†’ Type (a âŠ” b)" class="Function">Î£[</a> <a id="4291" href="1Lab.Equiv.Embedding.html#4291" class="Bound">f</a> <a id="4293" href="1Lab.Type.html#1573" data-type="(Bâ‚ : A â†’ Type b) â†’ Type (a âŠ” b)" class="Function">âˆˆ</a> <a id="4295" class="Symbol">(</a><a id="4296" href="1Lab.Equiv.Embedding.html#4280" class="Bound">A</a> <a id="4298" class="Symbol">â†’</a> <a id="4300" href="1Lab.Equiv.Embedding.html#4284" class="Bound">B</a><a id="4301" class="Symbol">)</a> <a id="4303" href="1Lab.Type.html#1573" data-type="(Bâ‚ : A â†’ Type b) â†’ Type (a âŠ” b)" class="Function">]</a> <a id="4305" href="1Lab.Equiv.Embedding.html#4172" data-type="(A â†’ Bâ‚) â†’ Type (A.â„“ âŠ” B.â„“)" class="Function">is-embedding</a> <a id="4318" href="1Lab.Equiv.Embedding.html#4291" class="Bound">f</a>
</pre>
<p>Univalence â€” specifically, the existence of classifying objects for
maps with
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span>-fibres</span>
â€” tells us that the embeddings into
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>
correspond to the families of propositional types over
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>.</span></p>
<pre class="Agda"><a id="subtype-classifier"></a><a id="4527" href="1Lab.Equiv.Embedding.html#4527" data-type="Î£ (Î» A â†’ A â†£ Bâ‚) â‰ƒ (Bâ‚ â†’ Î£ is-prop)" class="Function">subtype-classifier</a>
  <a id="4548" class="Symbol">:</a> <a id="4550" class="Symbol">âˆ€</a> <a id="4552" class="Symbol">{</a><a id="4553" href="1Lab.Equiv.Embedding.html#4553" class="Bound">â„“</a><a id="4554" class="Symbol">}</a> <a id="4556" class="Symbol">{</a><a id="4557" href="1Lab.Equiv.Embedding.html#4557" class="Bound">B</a> <a id="4559" class="Symbol">:</a> <a id="4561" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4566" href="1Lab.Equiv.Embedding.html#4553" class="Bound">â„“</a><a id="4567" class="Symbol">}</a>
  <a id="4571" class="Symbol">â†’</a> <a id="4573" class="Symbol">(</a><a id="4574" href="1Lab.Type.html#1573" data-type="(Bâ‚ : A â†’ Type b) â†’ Type (a âŠ” b)" class="Function">Î£[</a> <a id="4577" href="1Lab.Equiv.Embedding.html#4577" class="Bound">A</a> <a id="4579" href="1Lab.Type.html#1573" data-type="(Bâ‚ : A â†’ Type b) â†’ Type (a âŠ” b)" class="Function">âˆˆ</a> <a id="4581" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4586" href="1Lab.Equiv.Embedding.html#4553" class="Bound">â„“</a> <a id="4588" href="1Lab.Type.html#1573" data-type="(Bâ‚ : A â†’ Type b) â†’ Type (a âŠ” b)" class="Function">]</a> <a id="4590" class="Symbol">(</a><a id="4591" href="1Lab.Equiv.Embedding.html#4577" class="Bound">A</a> <a id="4593" href="1Lab.Equiv.Embedding.html#4248" data-type="Type â„“ â†’ Type â„“â‚ â†’ Type (â„“ âŠ” â„“â‚)" class="Function Operator">â†ª</a> <a id="4595" href="1Lab.Equiv.Embedding.html#4557" class="Bound">B</a><a id="4596" class="Symbol">))</a> <a id="4599" href="1Lab.Equiv.html#2439" data-type="Type â„“â‚ â†’ Type â„“â‚‚ â†’ Type (â„“â‚ âŠ” â„“â‚‚)" class="Function Operator">â‰ƒ</a> <a id="4601" class="Symbol">(</a><a id="4602" href="1Lab.Equiv.Embedding.html#4557" class="Bound">B</a> <a id="4604" class="Symbol">â†’</a> <a id="4606" href="1Lab.Type.html#1573" data-type="(Bâ‚ : A â†’ Type b) â†’ Type (a âŠ” b)" class="Function">Î£[</a> <a id="4609" href="1Lab.Equiv.Embedding.html#4609" class="Bound">T</a> <a id="4611" href="1Lab.Type.html#1573" data-type="(Bâ‚ : A â†’ Type b) â†’ Type (a âŠ” b)" class="Function">âˆˆ</a> <a id="4613" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="4618" href="1Lab.Equiv.Embedding.html#4553" class="Bound">â„“</a> <a id="4620" href="1Lab.Type.html#1573" data-type="(Bâ‚ : A â†’ Type b) â†’ Type (a âŠ” b)" class="Function">]</a> <a id="4622" class="Symbol">(</a><a id="4623" href="1Lab.HLevel.html#2597" data-type="Type â„“ â†’ Type â„“" class="Function">is-prop</a> <a id="4631" href="1Lab.Equiv.Embedding.html#4609" class="Bound">T</a><a id="4632" class="Symbol">))</a>
<a id="4635" href="1Lab.Equiv.Embedding.html#4527" data-type="Î£ (Î» A â†’ A â†£ Bâ‚) â‰ƒ (Bâ‚ â†’ Î£ is-prop)" class="Function">subtype-classifier</a> <a id="4654" class="Symbol">{</a><a id="4655" href="1Lab.Equiv.Embedding.html#4655" class="Bound">â„“</a><a id="4656" class="Symbol">}</a> <a id="4658" class="Symbol">=</a> <a id="4660" href="1Lab.Univalence.html#27033" data-type="(P : Type (â„“ âŠ” â„“&#39;) â†’ Type â„“&#39;&#39;) â†’ (â„“ /[ P ] Bâ‚) â‰ƒ (Bâ‚ â†’ Î£ P)" class="Function">Map-classifier</a> <a id="4675" class="Symbol">{</a><a id="4676" class="Argument">â„“</a> <a id="4678" class="Symbol">=</a> <a id="4680" href="1Lab.Equiv.Embedding.html#4655" class="Bound">â„“</a><a id="4681" class="Symbol">}</a> <a id="4683" href="1Lab.HLevel.html#2597" data-type="Type â„“ â†’ Type â„“" class="Function">is-prop</a>
</pre>
<p>A canonical source of embedding, then, are the first projections from
total spaces of propositional families. This is because, as
<span class="Agda"><a href="1Lab.Univalence.html#22945" class="Function">Fibre-equiv</a></span>
tells us, the fibre of
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>Ï€</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">\pi_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">Ï€</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
over
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>
is equivalent to â€œthe space of possible second coordinatesâ€, i.e.,
<span style="white-space: nowrap;"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>.</span>
Since
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span>
was assumed to be a prop., then so are the fibres of
<span class="Agda"><a href="Agda.Builtin.Sigma.html#252" class="Field">fst</a></span>.</p>
<pre class="Agda"><a id="Subset-proj-embedding"></a><a id="5051" href="1Lab.Equiv.Embedding.html#5051" data-type="((x : A) â†’ is-prop (Bâ‚ x)) â†’ is-embedding fst" class="Function">Subset-proj-embedding</a>
  <a id="5075" class="Symbol">:</a> <a id="5077" class="Symbol">âˆ€</a> <a id="5079" class="Symbol">{</a><a id="5080" href="1Lab.Equiv.Embedding.html#5080" class="Bound">B</a> <a id="5082" class="Symbol">:</a> <a id="5084" href="1Lab.Equiv.Embedding.html#626" class="Generalizable">A</a> <a id="5086" class="Symbol">â†’</a> <a id="5088" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5093" href="1Lab.Equiv.Embedding.html#611" class="Generalizable">â„“</a><a id="5094" class="Symbol">}</a> <a id="5096" class="Symbol">â†’</a> <a id="5098" class="Symbol">(âˆ€</a> <a id="5101" href="1Lab.Equiv.Embedding.html#5101" class="Bound">x</a> <a id="5103" class="Symbol">â†’</a> <a id="5105" href="1Lab.HLevel.html#2597" data-type="Type â„“ â†’ Type â„“" class="Function">is-prop</a> <a id="5113" class="Symbol">(</a><a id="5114" href="1Lab.Equiv.Embedding.html#5080" class="Bound">B</a> <a id="5116" href="1Lab.Equiv.Embedding.html#5101" class="Bound">x</a><a id="5117" class="Symbol">))</a>
  <a id="5122" class="Symbol">â†’</a> <a id="5124" href="1Lab.Equiv.Embedding.html#4172" data-type="(A â†’ Bâ‚) â†’ Type (A.â„“ âŠ” B.â„“)" class="Function">is-embedding</a> <a id="5137" class="Symbol">{</a><a id="5138" class="Argument">A</a> <a id="5140" class="Symbol">=</a> <a id="5142" href="1Lab.Type.html#1573" data-type="(Bâ‚ : A â†’ Type b) â†’ Type (a âŠ” b)" class="Function">Î£</a> <a id="5144" href="1Lab.Equiv.Embedding.html#5080" class="Bound">B</a><a id="5145" class="Symbol">}</a> <a id="5147" href="Agda.Builtin.Sigma.html#252" data-type="âˆ‘ A Bâ‚ â†’ A" class="Field">fst</a>
<a id="5151" href="1Lab.Equiv.Embedding.html#5051" data-type="((x : A) â†’ is-prop (Bâ‚ x)) â†’ is-embedding fst" class="Function">Subset-proj-embedding</a> <a id="5173" class="Symbol">{</a><a id="5174" class="Argument">B</a> <a id="5176" class="Symbol">=</a> <a id="5178" href="1Lab.Equiv.Embedding.html#5178" class="Bound">B</a><a id="5179" class="Symbol">}</a> <a id="5181" href="1Lab.Equiv.Embedding.html#5181" class="Bound">Bprop</a> <a id="5187" href="1Lab.Equiv.Embedding.html#5187" class="Bound">x</a> <a id="5189" class="Symbol">=</a> <a id="5191" href="1Lab.HLevel.Retracts.html#4220" data-type="(n : Nat) â†’ A â‰ƒ Bâ‚ â†’ is-hlevel A n â†’ is-hlevel Bâ‚ n" class="Function">is-hlevelâ‰ƒ</a> <a id="5202" class="Number">1</a> <a id="5204" class="Symbol">(</a><a id="5205" href="1Lab.Univalence.html#22945" data-type="(Bâ‚ : A â†’ Type â„“&#39;) (a : A) â†’ fibre fst a â‰ƒ Bâ‚ a" class="Function">Fibre-equiv</a> <a id="5217" href="1Lab.Equiv.Embedding.html#5178" class="Bound">B</a> <a id="5219" href="1Lab.Equiv.Embedding.html#5187" class="Bound">x</a> <a id="5221" href="1Lab.Equiv.html#21355" data-type="A â‰ƒ Bâ‚ â†’ Bâ‚ â‰ƒ A" class="Function Operator">eâ»Â¹</a><a id="5224" class="Symbol">)</a> <a id="5226" class="Symbol">(</a><a id="5227" href="1Lab.Equiv.Embedding.html#5181" class="Bound">Bprop</a> <a id="5233" class="Symbol">_)</a>
</pre>
!â€“
<pre class="Agda"><a id="embeddingâ†’monic"></a><a id="5253" href="1Lab.Equiv.Embedding.html#5253" data-type="is-embedding f â†’ (g h : C â†’ A) â†’ f âŠ™ g â‰¡ f âŠ™ h â†’ g â‰¡ h" class="Function">embeddingâ†’monic</a>
  <a id="5271" class="Symbol">:</a> <a id="5273" class="Symbol">âˆ€</a> <a id="5275" class="Symbol">{</a><a id="5276" href="1Lab.Equiv.Embedding.html#5276" class="Bound">â„“</a> <a id="5278" href="1Lab.Equiv.Embedding.html#5278" class="Bound">â„“â€²</a> <a id="5281" href="1Lab.Equiv.Embedding.html#5281" class="Bound">â„“â€²â€²</a><a id="5284" class="Symbol">}</a> <a id="5286" class="Symbol">{</a><a id="5287" href="1Lab.Equiv.Embedding.html#5287" class="Bound">A</a> <a id="5289" class="Symbol">:</a> <a id="5291" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5296" href="1Lab.Equiv.Embedding.html#5276" class="Bound">â„“</a><a id="5297" class="Symbol">}</a> <a id="5299" class="Symbol">{</a><a id="5300" href="1Lab.Equiv.Embedding.html#5300" class="Bound">B</a> <a id="5302" class="Symbol">:</a> <a id="5304" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5309" href="1Lab.Equiv.Embedding.html#5278" class="Bound">â„“â€²</a><a id="5311" class="Symbol">}</a> <a id="5313" class="Symbol">{</a><a id="5314" href="1Lab.Equiv.Embedding.html#5314" class="Bound">f</a> <a id="5316" class="Symbol">:</a> <a id="5318" href="1Lab.Equiv.Embedding.html#5287" class="Bound">A</a> <a id="5320" class="Symbol">â†’</a> <a id="5322" href="1Lab.Equiv.Embedding.html#5300" class="Bound">B</a><a id="5323" class="Symbol">}</a>
  <a id="5327" class="Symbol">â†’</a> <a id="5329" href="1Lab.Equiv.Embedding.html#4172" data-type="(A â†’ Bâ‚) â†’ Type (A.â„“ âŠ” B.â„“)" class="Function">is-embedding</a> <a id="5342" href="1Lab.Equiv.Embedding.html#5314" class="Bound">f</a>
  <a id="5346" class="Symbol">â†’</a> <a id="5348" class="Symbol">âˆ€</a> <a id="5350" class="Symbol">{</a><a id="5351" href="1Lab.Equiv.Embedding.html#5351" class="Bound">C</a> <a id="5353" class="Symbol">:</a> <a id="5355" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5360" href="1Lab.Equiv.Embedding.html#5281" class="Bound">â„“â€²â€²</a><a id="5363" class="Symbol">}</a> <a id="5365" class="Symbol">(</a><a id="5366" href="1Lab.Equiv.Embedding.html#5366" class="Bound">g</a> <a id="5368" href="1Lab.Equiv.Embedding.html#5368" class="Bound">h</a> <a id="5370" class="Symbol">:</a> <a id="5372" href="1Lab.Equiv.Embedding.html#5351" class="Bound">C</a> <a id="5374" class="Symbol">â†’</a> <a id="5376" href="1Lab.Equiv.Embedding.html#5287" class="Bound">A</a><a id="5377" class="Symbol">)</a> <a id="5379" class="Symbol">â†’</a> <a id="5381" href="1Lab.Equiv.Embedding.html#5314" class="Bound">f</a> <a id="5383" href="1Lab.Type.html#2227" data-type="((y : Bâ‚ x) â†’ C x y) â†’ (f : (x : A) â†’ Bâ‚ x) (x : A) â†’ C x (f x)" class="Function Operator">âˆ˜</a> <a id="5385" href="1Lab.Equiv.Embedding.html#5366" class="Bound">g</a> <a id="5387" href="Agda.Builtin.Cubical.Path.html#388" data-type="A â†’ A â†’ Type â„“" class="Function Operator">â‰¡</a> <a id="5389" href="1Lab.Equiv.Embedding.html#5314" class="Bound">f</a> <a id="5391" href="1Lab.Type.html#2227" data-type="((y : Bâ‚ x) â†’ C x y) â†’ (f : (x : A) â†’ Bâ‚ x) (x : A) â†’ C x (f x)" class="Function Operator">âˆ˜</a> <a id="5393" href="1Lab.Equiv.Embedding.html#5368" class="Bound">h</a> <a id="5395" class="Symbol">â†’</a> <a id="5397" href="1Lab.Equiv.Embedding.html#5366" class="Bound">g</a> <a id="5399" href="Agda.Builtin.Cubical.Path.html#388" data-type="A â†’ A â†’ Type â„“" class="Function Operator">â‰¡</a> <a id="5401" href="1Lab.Equiv.Embedding.html#5368" class="Bound">h</a>
<a id="5403" href="1Lab.Equiv.Embedding.html#5253" data-type="is-embedding f â†’ (g h : C â†’ A) â†’ f âŠ™ g â‰¡ f âŠ™ h â†’ g â‰¡ h" class="Function">embeddingâ†’monic</a> <a id="5419" class="Symbol">{</a><a id="5420" class="Argument">f</a> <a id="5422" class="Symbol">=</a> <a id="5424" href="1Lab.Equiv.Embedding.html#5424" class="Bound">f</a><a id="5425" class="Symbol">}</a> <a id="5427" href="1Lab.Equiv.Embedding.html#5427" class="Bound">emb</a> <a id="5431" href="1Lab.Equiv.Embedding.html#5431" class="Bound">g</a> <a id="5433" href="1Lab.Equiv.Embedding.html#5433" class="Bound">h</a> <a id="5435" href="1Lab.Equiv.Embedding.html#5435" class="Bound">p</a> <a id="5437" class="Symbol">=</a>
  <a id="5441" href="1Lab.Path.html#58486" data-type="((x : A) â†’ f x â‰¡ g x) â†’ f â‰¡ g" class="Function">funext</a> <a id="5448" class="Symbol">Î»</a> <a id="5450" href="1Lab.Equiv.Embedding.html#5450" class="Bound">x</a> <a id="5452" class="Symbol">â†’</a> <a id="5454" href="1Lab.Path.html#20756" data-type="(f : (x : A) â†’ Bâ‚ x) (p : x â‰¡ y) â†’
PathP (Î» i â†’ Bâ‚ (p i)) (f x) (f y)" class="Function">ap</a> <a id="5457" href="Agda.Builtin.Sigma.html#252" data-type="âˆ‘ A Bâ‚ â†’ A" class="Field">fst</a> <a id="5461" class="Symbol">(</a><a id="5462" href="1Lab.Equiv.Embedding.html#5427" class="Bound">emb</a> <a id="5466" class="Symbol">_</a> <a id="5468" class="Symbol">(</a><a id="5469" href="1Lab.Equiv.Embedding.html#5431" class="Bound">g</a> <a id="5471" href="1Lab.Equiv.Embedding.html#5450" class="Bound">x</a> <a id="5473" href="Agda.Builtin.Sigma.html#236" data-type="(fstâ‚ : A) (sndâ‚ : Bâ‚ fstâ‚) â†’ âˆ‘ A Bâ‚" class="InductiveConstructor Operator">,</a> <a id="5475" href="1Lab.Path.html#3593" data-type="x â‰¡ x" class="Function">refl</a><a id="5479" class="Symbol">)</a> <a id="5481" class="Symbol">(</a><a id="5482" href="1Lab.Equiv.Embedding.html#5433" class="Bound">h</a> <a id="5484" href="1Lab.Equiv.Embedding.html#5450" class="Bound">x</a> <a id="5486" href="Agda.Builtin.Sigma.html#236" data-type="(fstâ‚ : A) (sndâ‚ : Bâ‚ fstâ‚) â†’ âˆ‘ A Bâ‚" class="InductiveConstructor Operator">,</a> <a id="5488" href="1Lab.Path.html#58127" data-type="f â‰¡ g â†’ (x : A) â†’ f x â‰¡ g x" class="Function">happly</a> <a id="5495" class="Symbol">(</a><a id="5496" href="1Lab.Path.html#10558" data-type="x â‰¡ y â†’ y â‰¡ x" class="Function">sym</a> <a id="5500" href="1Lab.Equiv.Embedding.html#5435" class="Bound">p</a><a id="5501" class="Symbol">)</a> <a id="5503" href="1Lab.Equiv.Embedding.html#5450" class="Bound">x</a><a id="5504" class="Symbol">))</a>

<a id="monic-between-setsâ†’is-embedding"></a><a id="5508" href="1Lab.Equiv.Embedding.html#5508" data-type="is-set Bâ‚ â†’
((g h : âˆ£ C âˆ£ â†’ A) â†’ f âŠ™ g â‰¡ f âŠ™ h â†’ g â‰¡ h) â†’ is-embedding f" class="Function">monic-between-setsâ†’is-embedding</a>
  <a id="5542" class="Symbol">:</a> <a id="5544" class="Symbol">âˆ€</a> <a id="5546" class="Symbol">{</a><a id="5547" href="1Lab.Equiv.Embedding.html#5547" class="Bound">â„“</a> <a id="5549" href="1Lab.Equiv.Embedding.html#5549" class="Bound">â„“â€²</a> <a id="5552" href="1Lab.Equiv.Embedding.html#5552" class="Bound">â„“â€²â€²</a><a id="5555" class="Symbol">}</a> <a id="5557" class="Symbol">{</a><a id="5558" href="1Lab.Equiv.Embedding.html#5558" class="Bound">A</a> <a id="5560" class="Symbol">:</a> <a id="5562" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5567" href="1Lab.Equiv.Embedding.html#5547" class="Bound">â„“</a><a id="5568" class="Symbol">}</a> <a id="5570" class="Symbol">{</a><a id="5571" href="1Lab.Equiv.Embedding.html#5571" class="Bound">B</a> <a id="5573" class="Symbol">:</a> <a id="5575" href="1Lab.Type.html#391" class="Primitive">Type</a> <a id="5580" href="1Lab.Equiv.Embedding.html#5549" class="Bound">â„“â€²</a><a id="5582" class="Symbol">}</a> <a id="5584" class="Symbol">{</a><a id="5585" href="1Lab.Equiv.Embedding.html#5585" class="Bound">f</a> <a id="5587" class="Symbol">:</a> <a id="5589" href="1Lab.Equiv.Embedding.html#5558" class="Bound">A</a> <a id="5591" class="Symbol">â†’</a> <a id="5593" href="1Lab.Equiv.Embedding.html#5571" class="Bound">B</a><a id="5594" class="Symbol">}</a>
  <a id="5598" class="Symbol">â†’</a> <a id="5600" href="1Lab.HLevel.html#3356" data-type="Type â„“ â†’ Type â„“" class="Function">is-set</a> <a id="5607" href="1Lab.Equiv.Embedding.html#5571" class="Bound">B</a>
  <a id="5611" class="Symbol">â†’</a> <a id="5613" class="Symbol">(âˆ€</a> <a id="5616" class="Symbol">{</a><a id="5617" href="1Lab.Equiv.Embedding.html#5617" class="Bound">C</a> <a id="5619" class="Symbol">:</a> <a id="5621" href="1Lab.HLevel.Universe.html#5464" data-type="(â„“ : Level) â†’ Type (lsuc â„“)" class="Function">Set</a> <a id="5625" href="1Lab.Equiv.Embedding.html#5552" class="Bound">â„“â€²â€²</a><a id="5628" class="Symbol">}</a> <a id="5630" class="Symbol">(</a><a id="5631" href="1Lab.Equiv.Embedding.html#5631" class="Bound">g</a> <a id="5633" href="1Lab.Equiv.Embedding.html#5633" class="Bound">h</a> <a id="5635" class="Symbol">:</a> <a id="5637" href="1Lab.HLevel.Universe.html#3210" data-type="n-Type â„“ n â†’ Type â„“" class="Field Operator">âˆ£</a> <a id="5639" href="1Lab.Equiv.Embedding.html#5617" class="Bound">C</a> <a id="5641" href="1Lab.HLevel.Universe.html#3210" data-type="n-Type â„“ n â†’ Type â„“" class="Field Operator">âˆ£</a> <a id="5643" class="Symbol">â†’</a> <a id="5645" href="1Lab.Equiv.Embedding.html#5558" class="Bound">A</a><a id="5646" class="Symbol">)</a> <a id="5648" class="Symbol">â†’</a> <a id="5650" href="1Lab.Equiv.Embedding.html#5585" class="Bound">f</a> <a id="5652" href="1Lab.Type.html#2227" data-type="((y : Bâ‚ x) â†’ C x y) â†’ (f : (x : A) â†’ Bâ‚ x) (x : A) â†’ C x (f x)" class="Function Operator">âˆ˜</a> <a id="5654" href="1Lab.Equiv.Embedding.html#5631" class="Bound">g</a> <a id="5656" href="Agda.Builtin.Cubical.Path.html#388" data-type="A â†’ A â†’ Type â„“" class="Function Operator">â‰¡</a> <a id="5658" href="1Lab.Equiv.Embedding.html#5585" class="Bound">f</a> <a id="5660" href="1Lab.Type.html#2227" data-type="((y : Bâ‚ x) â†’ C x y) â†’ (f : (x : A) â†’ Bâ‚ x) (x : A) â†’ C x (f x)" class="Function Operator">âˆ˜</a> <a id="5662" href="1Lab.Equiv.Embedding.html#5633" class="Bound">h</a> <a id="5664" class="Symbol">â†’</a> <a id="5666" href="1Lab.Equiv.Embedding.html#5631" class="Bound">g</a> <a id="5668" href="Agda.Builtin.Cubical.Path.html#388" data-type="A â†’ A â†’ Type â„“" class="Function Operator">â‰¡</a> <a id="5670" href="1Lab.Equiv.Embedding.html#5633" class="Bound">h</a><a id="5671" class="Symbol">)</a>
  <a id="5675" class="Symbol">â†’</a> <a id="5677" href="1Lab.Equiv.Embedding.html#4172" data-type="(A â†’ Bâ‚) â†’ Type (A.â„“ âŠ” B.â„“)" class="Function">is-embedding</a> <a id="5690" href="1Lab.Equiv.Embedding.html#5585" class="Bound">f</a>
<a id="5692" href="1Lab.Equiv.Embedding.html#5508" data-type="is-set Bâ‚ â†’
((g h : âˆ£ C âˆ£ â†’ A) â†’ f âŠ™ g â‰¡ f âŠ™ h â†’ g â‰¡ h) â†’ is-embedding f" class="Function">monic-between-setsâ†’is-embedding</a> <a id="5724" class="Symbol">{</a><a id="5725" class="Argument">f</a> <a id="5727" class="Symbol">=</a> <a id="5729" href="1Lab.Equiv.Embedding.html#5729" class="Bound">f</a><a id="5730" class="Symbol">}</a> <a id="5732" href="1Lab.Equiv.Embedding.html#5732" class="Bound">bset</a> <a id="5737" href="1Lab.Equiv.Embedding.html#5737" class="Bound">monic</a> <a id="5743" class="Symbol">=</a>
  <a id="5747" href="1Lab.Equiv.Embedding.html#1491" data-type="is-set Bâ‚ â†’
(f : A â†’ Bâ‚) â†’ injective f â†’ (x : Bâ‚) â†’ is-prop (fibre f x)" class="Function">injective-between-setsâ†’has-prop-fibres</a> <a id="5786" href="1Lab.Equiv.Embedding.html#5732" class="Bound">bset</a> <a id="5791" class="Symbol">_</a> <a id="5793" class="Symbol">Î»</a> <a id="5795" class="Symbol">{</a><a id="5796" href="1Lab.Equiv.Embedding.html#5796" class="Bound">x</a><a id="5797" class="Symbol">}</a> <a id="5799" class="Symbol">{</a><a id="5800" href="1Lab.Equiv.Embedding.html#5800" class="Bound">y</a><a id="5801" class="Symbol">}</a> <a id="5803" href="1Lab.Equiv.Embedding.html#5803" class="Bound">p</a> <a id="5805" class="Symbol">â†’</a>
    <a id="5811" href="1Lab.Path.html#58127" data-type="f â‰¡ g â†’ (x : A) â†’ f x â‰¡ g x" class="Function">happly</a> <a id="5818" class="Symbol">(</a><a id="5819" href="1Lab.Equiv.Embedding.html#5737" class="Bound">monic</a> <a id="5825" class="Symbol">{</a><a id="5826" class="Argument">C</a> <a id="5828" class="Symbol">=</a> <a id="5830" href="1Lab.Type.html#2016" data-type="(â„“ : Level) (A : Type a) â†’ Type (a âŠ” â„“)" class="Record">Lift</a> <a id="5835" class="Symbol">_</a> <a id="5837" href="Agda.Builtin.Unit.html#164" data-type="Type" class="Record">âŠ¤</a> <a id="5839" href="1Lab.HLevel.Universe.html#3194" data-type="(âˆ£_âˆ£â‚ : Type â„“) (is-trâ‚ : is-hlevel âˆ£_âˆ£â‚ n) â†’ n-Type â„“ n" class="InductiveConstructor Operator">,</a> <a id="5841" class="Symbol">Î»</a> <a id="5843" href="1Lab.Equiv.Embedding.html#5843" class="Bound">_</a> <a id="5845" href="1Lab.Equiv.Embedding.html#5845" class="Bound">_</a> <a id="5847" href="1Lab.Equiv.Embedding.html#5847" class="Bound">_</a> <a id="5849" href="1Lab.Equiv.Embedding.html#5849" class="Bound">_</a> <a id="5851" href="1Lab.Equiv.Embedding.html#5851" class="Bound">i</a> <a id="5853" href="1Lab.Equiv.Embedding.html#5853" class="Bound">j</a> <a id="5855" class="Symbol">â†’</a> <a id="5857" href="1Lab.Type.html#2075" data-type="(lower : A) â†’ Lift â„“ A" class="InductiveConstructor">lift</a> <a id="5862" href="Agda.Builtin.Unit.html#201" data-type="âŠ¤" class="InductiveConstructor">tt</a><a id="5864" class="Symbol">}</a> <a id="5866" class="Symbol">(Î»</a> <a id="5869" href="1Lab.Equiv.Embedding.html#5869" class="Bound">_</a> <a id="5871" class="Symbol">â†’</a> <a id="5873" href="1Lab.Equiv.Embedding.html#5796" class="Bound">x</a><a id="5874" class="Symbol">)</a> <a id="5876" class="Symbol">(Î»</a> <a id="5879" href="1Lab.Equiv.Embedding.html#5879" class="Bound">_</a> <a id="5881" class="Symbol">â†’</a> <a id="5883" href="1Lab.Equiv.Embedding.html#5800" class="Bound">y</a><a id="5884" class="Symbol">)</a> <a id="5886" class="Symbol">(</a><a id="5887" href="1Lab.Path.html#58486" data-type="((x : A) â†’ f x â‰¡ g x) â†’ f â‰¡ g" class="Function">funext</a> <a id="5894" class="Symbol">(Î»</a> <a id="5897" href="1Lab.Equiv.Embedding.html#5897" class="Bound">_</a> <a id="5899" class="Symbol">â†’</a> <a id="5901" href="1Lab.Equiv.Embedding.html#5803" class="Bound">p</a><a id="5902" class="Symbol">)))</a> <a id="5906" class="Symbol">_</a>
</pre>
<p>â€“</p>
  </article>
</div>
</main>
</body>
<style>.equations { display: none !important; }</style></html>
